
!=====================================================================!
! A module that wraps all the data used in Newton solve
!
! Author :  Komahan Boopathy (komahan@gatech.edu)
!=====================================================================!

module newton_solve_bean_class

  use precision

  implicit none

  private

  public :: newton_solve_bean

  type newton_solve_bean

     !----------------------------------------------------------------!
     ! Basic setup variables
     !----------------------------------------------------------------!

     integer :: max_newton_iters = 50
     integer :: nvars = 1
     integer :: iter_num = 0

     !----------------------------------------------------------------!
     ! Stopping criteria
     !----------------------------------------------------------------!

     ! absolute tolerances
     real(dp) :: atol_rnrm = 1.0d-12
     real(dp) :: atol_unrm = 1.0d-12

     ! relative tolerances
     real(dp) :: rtol_rnrm = 1.0d-6
     real(dp) :: rtol_unrm = 1.0d-6

     ! actual norm values
     real(dp), dimension(:), allocatable :: rnrm, unrm

     !----------------------------------------------------------------!
     ! Print and solution write control
     !----------------------------------------------------------------!

     integer :: filenum              = 6 
     logical :: write_newton_details = .true.
     logical :: exit_on_failure      = .false. 
     
     logical :: converged = .false. 

   contains

     procedure :: get_max_newton_iters, set_max_newton_iters
     procedure :: get_num_vars, set_num_vars

     procedure :: get_atol_unrm, set_atol_unrm
     procedure :: get_atol_rnrm, set_atol_rnrm

     procedure :: get_rtol_unrm, set_rtol_unrm
     procedure :: get_rtol_rnrm, set_rtol_rnrm

     procedure :: set_file_number
     procedure :: set_write_newton_details
     procedure :: set_exit_on_failure

  end type newton_solve_bean
  
contains

  !-------------------------------------------------------------------!
  ! Get max_newton_iters
  !-------------------------------------------------------------------!

  integer function get_max_newton_iters(this)

    class(newton_solve_bean) :: this

    get_max_newton_iters = this % max_newton_iters

  end function get_max_newton_iters

  !-------------------------------------------------------------------!
  ! Set max_newton_iters
  !-------------------------------------------------------------------!

  subroutine set_max_newton_iters(this, max_newton_iters)

    class(newton_solve_bean) :: this
    integer :: max_newton_iters

    this % max_newton_iters =  max_newton_iters

  end subroutine set_max_newton_iters

  !-------------------------------------------------------------------!
  ! Get number of variables
  !-------------------------------------------------------------------!

  integer function get_num_vars(this)

    class(newton_solve_bean) :: this

    get_num_vars = this % nvars

  end function get_num_vars

  !-------------------------------------------------------------------!
  ! Set number of variables
  !-------------------------------------------------------------------!

  subroutine set_num_vars(this, nvars)

    class(newton_solve_bean) :: this
    integer :: nvars

    this % nvars = nvars

  end subroutine set_num_vars

  !-------------------------------------------------------------------!
  ! Get absolute tolerance of update norm
  !-------------------------------------------------------------------!

  real(dp) function get_atol_unrm(this)

    class(newton_solve_bean) :: this

    get_atol_unrm  = this % atol_unrm

  end function get_atol_unrm

  !-------------------------------------------------------------------!
  ! Set absolute tolerance of update norm
  !-------------------------------------------------------------------!

  subroutine set_atol_unrm(this, atol_unrm)

    class(newton_solve_bean) :: this
    real(dp) :: atol_unrm

    this % atol_unrm = atol_unrm

  end subroutine set_atol_unrm

  !-------------------------------------------------------------------!
  ! Get absolute tolerance of residual norm
  !-------------------------------------------------------------------!

  real(dp) function get_atol_rnrm(this)

    class(newton_solve_bean) :: this

    get_atol_rnrm  = this % atol_rnrm

  end function get_atol_rnrm

  !-------------------------------------------------------------------!
  ! Set absolute tolerance of residual norm
  !-------------------------------------------------------------------!

  subroutine set_atol_rnrm(this, atol_rnrm)

    class(newton_solve_bean) :: this
    real(dp) :: atol_rnrm

    this % atol_rnrm = atol_rnrm

  end subroutine set_atol_rnrm

  !-------------------------------------------------------------------!
  ! Get relative tolerance of update norm
  !-------------------------------------------------------------------!

  real(dp) function get_rtol_unrm(this)

    class(newton_solve_bean) :: this

    get_rtol_unrm  = this % rtol_unrm

  end function get_rtol_unrm

  !-------------------------------------------------------------------!
  ! Set relative tolerance of update norm
  !-------------------------------------------------------------------!

  subroutine set_rtol_unrm(this, rtol_unrm)

    class(newton_solve_bean) :: this
    real(dp) :: rtol_unrm

    this % rtol_unrm = rtol_unrm

  end subroutine set_rtol_unrm

  !-------------------------------------------------------------------!
  ! Get relative tolerance of residual norm
  !-------------------------------------------------------------------!

  real(dp) function get_rtol_rnrm(this)

    class(newton_solve_bean) :: this

    get_rtol_rnrm  = this % rtol_rnrm

  end function get_rtol_rnrm

  !-------------------------------------------------------------------!
  ! Set relative tolerance of residual norm
  !-------------------------------------------------------------------!

  subroutine set_rtol_rnrm(this, rtol_rnrm)

    class(newton_solve_bean) :: this
    real(dp) :: rtol_rnrm

    this % rtol_rnrm = rtol_rnrm

  end subroutine set_rtol_rnrm

  !-------------------------------------------------------------------!
  ! Set the output file number
  !-------------------------------------------------------------------!

  subroutine set_file_number(this, filenum)

    class(newton_solve_bean) :: this
    integer :: filenum

    this % filenum = filenum

  end subroutine set_file_number

  !-------------------------------------------------------------------!
  ! Set the print control for writing the details of newton solve
  !-------------------------------------------------------------------!

  subroutine set_write_newton_details(this, write_newton_details)

    class(newton_solve_bean) :: this
    logical :: write_newton_details

    this % write_newton_details = write_newton_details

  end subroutine set_write_newton_details

  !-------------------------------------------------------------------!
  ! Set whether or not to exit when not converged
  !-------------------------------------------------------------------!

  subroutine set_exit_on_failure(this, exit_on_failure)

    class(newton_solve_bean) :: this
    logical :: exit_on_failure

    this % exit_on_failure = exit_on_failure

  end subroutine set_exit_on_failure

  !-------------------------------------------------------------------!
  ! Set the initial value of x (starting point)
  !-------------------------------------------------------------------!

!!$  subroutine set_init_x(this, init_q)
!!$
!!$    class(newton_solve_bean) :: this
!!$    real(dp) :: init_q
!!$
!!$    this % init_q = init_q
!!$
!!$  end subroutine set_init_x
!!$
!!$  !-------------------------------------------------------------------!
!!$  ! Set the initial value of x (starting point)
!!$  !-------------------------------------------------------------------!
!!$
!!$  subroutine set_init_xdot(this, init_qdot)
!!$
!!$    class(newton_solve_bean) :: this
!!$    real(dp) :: init_qdot
!!$
!!$    this % init_qdot = init_qdot
!!$
!!$  end subroutine set_init_xdot

end module newton_solve_bean_class

!=====================================================================!
! A module that uses Newton's root finding method to approximate the
! solution to equations of the form R(q,qdot,qddot) = 0
!
! The module is generic, which means it can be used to find solutions
! (a) R = 0 (using R and dR values)
! (b) R'= 0 (using R' and d2R values)
!
! Usage : In a main program,
!
! type(newton_solve) :: newton ! create an instance of the solve
!
! call newton%init()
! call newton%solve()
!
! Author :  Komahan Boopathy (komahan@gatech.edu)
! =====================================================================!

module newton_solve_class

  ! import dependencies
  use precision
  use newton_solve_bean_class
  use system_class

  ! No implicit varaible definitions
  implicit none

  ! All routines and varaibles are private by default
  private

  ! Expose datatypes
  public :: newton_solve

  ! A type that contains the logic for Newton's method
  type, extends(newton_solve_bean) :: newton_solve

contains

  ! private procedures
  procedure, private :: init   => init
  procedure, private :: finish => finish
  procedure, private :: work   => work

  procedure, private :: linear_solve
  procedure, private :: check_stop
  procedure, private :: extrapolate

  ! public procedures
  procedure, public :: solve => solve

end type newton_solve

contains

  !-------------------------------------------------------------------!
  ! Solve the linear system to find the newton update
  !-------------------------------------------------------------------!

  subroutine linear_solve(this, step_num)

    class(newton_solve) :: this

    integer :: step_num
    real(dp):: rtmp, drtmp
    
    if (ndim .eq. 1) then
       rtmp  = R(step_num, 1)
       drtmp = dR(step_num, 1, 1)
       dq    = -rtmp/drtmp
    else
       stop"linear solve not implemented for ndim>1"
    end if

  end subroutine linear_solve

  !-------------------------------------------------------------------!
  ! Solve the linear system to find the newton update
  !-------------------------------------------------------------------!

  subroutine check_stop(this, step_num)

    class(newton_solve) :: this
    integer :: step_num
    
    this % rnrm (this % iter_num) = norm2(R(step_num,:))
    this % unrm (this % iter_num) = norm2(dq)
    
    if ((this % rnrm (this % iter_num) .le. this % get_atol_rnrm() ) .or. &
         &(this % unrm(this % iter_num) .le. this % get_atol_unrm() )) &
         & this % converged = .true.

  end subroutine check_stop

  !-------------------------------------------------------------------!
  ! Extrapolate to next time step
  !-------------------------------------------------------------------!

  subroutine extrapolate(this, step_num)
    class(newton_solve) :: this
    integer :: step_num
    
    if (step_num .gt. 1) then
       q(step_num,:) = q(step_num-1,:) + qdot(step_num-1,:)*dt  &
            &+ qddot(step_num-1,:)*dt2/2.0_dp
    end if
    
  end subroutine extrapolate

  !-------------------------------------------------------------------!
  ! Routine for initialization tasks
  !-------------------------------------------------------------------!
  
  subroutine init(this)

    class(newton_solve) :: this

    print *, "Initializing Newton Solve"

    if (allocated(this%rnrm)) deallocate(this%rnrm)
    allocate(this%rnrm(this%get_max_newton_iters()))
    this%rnrm = 0.0_dp

    if (allocated(this%unrm)) deallocate(this%unrm)
    allocate(this%unrm(this%get_max_newton_iters()))
    this%unrm = 0.0_dp

    ! initialize module variables
    call initialize(this%get_num_vars(), 2)
    ! call this % extrapolate(step_num)

  end subroutine init
  
  !-------------------------------------------------------------------!
  ! Routine that wraps the logic of newton solve                                                          
  !-------------------------------------------------------------------!
  
  subroutine work(this)

    use backward_difference

    class(newton_solve) :: this

    real(dp) :: R, dR
    integer  :: n

    print *, "Executing Newton solve"

    call this % extrapolate(2)

    newton: do n = 1, this % get_max_newton_iters()

       ! call this % set_iter_num(n)
       this % iter_num = this% iter_num + 1

       ! call this % extrapolate()

       call residual(2)

       call jacobian(2)

       call this % linear_solve(2)

       call update_states(2)

       call this % check_stop(2)

       if (this % converged) exit newton

    end do newton

  end subroutine work
  
  !-------------------------------------------------------------------!
  ! Routine that performs finishing tasks
  !-------------------------------------------------------------------!
  
  subroutine finish(this)

    class(newton_solve) :: this

    print *, "Finish Newton solve"

    if (allocated(this%rnrm)) deallocate(this%rnrm)
    if (allocated(this%unrm)) deallocate(this%unrm)

    call finalize

  end subroutine finish

  !-------------------------------------------------------------------!
  ! Routine that performs newton solve                                                                   
  !-------------------------------------------------------------------!

  subroutine solve(this)

    class(newton_solve) :: this

    ! perform initialization tasks
    call this % init()

    ! perform newton solve
    call this % work()

    ! perform finalization tasks
    call this % finish()

  end subroutine solve

end module newton_solve_class

!=====================================================================!
! Program to test newton_solve_class module
!=====================================================================!

program test_newton_solve_class

  use newton_solve_class
  !use variables

  implicit none  

  type(newton_solve) :: newton

  integer :: nvars  = 1
  integer :: nsteps = 1000
  integer :: k

  !call newton % init()

  ! Set optional parameters
  call newton % set_num_vars(nvars)
  call newton % set_exit_on_failure(.true.)

  time: do k = 2, nsteps

     ! solve the problem
     call newton % solve()

  end do time

  !call newton % finish()

  !call finalize

contains

end program test_newton_solve_class

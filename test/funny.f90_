program main

  implicit none

  !-------------------------------------------------------------------!
  !  Define constants to manage precision [TUNABLE]
  !-------------------------------------------------------------------!
  integer, parameter :: sp = kind(0.0)    ! single precision
  integer, parameter :: dp = kind(0.0d0)  ! double precision

  !-------------------------------------------------------------------!
  !  Integration constants
  !-------------------------------------------------------------------!  
  integer, parameter :: max_bdf_order = 2 ! maximum BDF integ order
  integer, parameter :: num_time_steps = 250   ! number of time steps
  integer, parameter :: max_newton_iters = 50   ! number of newton iters

  integer, parameter :: max_fo_terms = max_bdf_order*(max_bdf_order+1)/2
  integer, parameter :: max_so_terms = (2*max_bdf_order-1)*(2*max_bdf_order-1) + 1

  !real(dp), parameter :: beta(2*(max_bdf_order+1)-1) = (/ 2.25_dp, -6.0_dp, 5.5_dp, -2.0_dp, 0.25_dp /)
  !alpha(3, 1:4) = (/ 11.0_dp/6.0_dp, -3.0_dp, 1.5_dp, -1.0_dp/3.0_dp /)

  real(dp), parameter :: tinit  = 0.0_dp
  real(dp), parameter :: tfinal = 10.0_dp

  real(dp), parameter :: dt = (tfinal-tinit)/dble(num_time_steps)
  real(dp), parameter :: dt2 = dt*dt

  !-------------------------------------------------------------------!
  ! The system parameters 
  !-------------------------------------------------------------------!
  real(dp) :: M = 1.0_dp
  real(dp) :: C = 0.2_dp
  real(dp) :: K = 5.0_dp

  !-------------------------------------------------------------------!
  ! The state variable and derivatives
  !-------------------------------------------------------------------!
  real(dp)  :: alpha(max_bdf_order, max_fo_terms) = 0.0_dp
  real(dp)  :: beta(max_bdf_order, max_so_terms) = 0.0_dp

  real(dp) :: u(num_time_steps+1)     = 0.0_dp
  real(dp) :: udot(num_time_steps+1)  = 0.0_dp
  real(dp) :: uddot(num_time_steps+1) = 0.0_dp

  real(dp) :: dR ! jacobian
  real(dp) :: R  ! residual
  real(dp) :: du ! state update
  real(dp) :: rnrm
  real(dp) :: rnrm_tol = 1.0d-6

  integer  :: i, n ! loop variable
  integer  :: order = 0

  ! set the BDF coefficeints for first derivative
  alpha(1, 1:2) = (/ 1.0, -1.0 /)
  alpha(2, 1:3) = (/ 1.5_dp, -2.0_dp, 0.5_dp /)

  ! set the BDF coefficient for second derivative
  beta(1, 1:3) = (/ 1.0_dp, -2.0_dp, 1.0_dp /)
  beta(2, 1:5) = (/ 2.25_dp, -6.0_dp, 5.5_dp, -2.0_dp, 0.25_dp /)

  ! set the initial condition
  u(1) = 1.0_dp
  udot(1) = 0.0_dp
  uddot(1) = -(C*udot(1) + K*u(1))/M
  
  ! extrapolate to the first time step
  u(2) = u(1) + udot(1)*dt + uddot(1)*dt2/2.0d0
  ! approximate udot using first order BDF
  udot(2) = (u(2) - u(1))/dt
  ! find uddot(2) algebraically
  uddot(2) = -(C*udot(2) + K*u(2))/M

  ! extrapolate to the second time step
  u(3) = u(2) + udot(2)*dt + uddot(2)*dt2/2.0d0
  ! approximate udot using first order BDF
  udot(3) = (u(3) - u(2))/dt
  ! find uddot(3) algebraically
  uddot(3) = -(C*udot(3) + K*u(3))/M

  !print*, "initial   u(1)=", u(1), udot(1), uddot(1)
  !print*, "first     u(2)=", u(2), udot(2), uddot(2)
  !print*, "second    u(3)=", u(3), udot(3), uddot(3)
  
  print*, u(1), udot(1), uddot(1)
  print*, u(2), udot(2), uddot(2)
  print*, u(3), udot(3), uddot(3)
  
  do i = 2,num_time_steps
     ! extrapolate to the second time step
     u(i) = u(i-1) + udot(i-1)*dt + uddot(i-1)*dt2/2.0d0
     ! approximate udot using first order BDF
     udot(i) = (u(i) - u(i-1))/dt
     ! find uddot(3) algebraically
     uddot(i) = -(C*udot(i) + K*u(i))/M

     print*, u(i), udot(i), uddot(i)

  end do

!  R = M*uddot(2) + C*udot(2) + K*u(2)
!  print*, R
  stop
  print*, "extrapolated u=", u(2)

!  print*, dt, dt2

  dR = K + C/dt + M/dt2

  do n = 1, 10

     R = -M*(u(1)/dt2 + udot(1)/dt) +C*(u(2)-u(1))/dt + K*u(2)

     ! find the update
     du = R/dR

     ! apply the updates
     u(2) = u(2) - R/dR

!     udot(2) =  udot(2) + alpha(1, 1)*du/dt
!     uddot(2) =  uddot(2) + beta(1, 1)*du/dt2

!     print*, u(2), udot(2), uddot(2), du, R

  end do

  print*, "new u=", u(2), udot(2), uddot(2)


  stop
  
  !dR = K + C/dt + M/dt2

  !R = -(M*uddot(i) + C*udot(i) + K*u(i))

!  print*, 1,  u(1), udot(1), uddot(1)
  
  ! extrapolate to next time step (good starting point)
  ! uddot(i) =  (u(i) - u(i-1))/dt2 - udot(i-1)/dt
  
  time_march: do i = 2, num_time_steps

     ! Increase the order of time integration. Only have upto second
     ! order stencil here, so we limit
     order = order + 1
     if (order .gt. max_bdf_order) order = max_bdf_order

     u(i) = u(i-1) + udot(i-1)*dt + uddot(i-1)*dt2/2.0_dp

     ! find udot and uddot
     if (order .eq. 1) then

        udot(i) &
             &= alpha(1, 1)*u(i)/dt &
             &+ alpha(1, 2)*u(i-1)/dt

        uddot(i) =  (u(i) - u(i-1))/dt2 - udot(i-1)/dt


     else if (order .eq. 2) then

        udot(i) &
             &= alpha(2, 1)*u(i)/dt &
             &+ alpha(2, 2)*u(i-1)/dt &
             &+ alpha(2, 3)*u(i-2)/dt

        if (i .le. 4) then
           
           uddot(i) &
                &= beta(1, 1)*u(i)/dt2 &
                &+ beta(1, 2)*u(i-1)/dt2 &
                &+ beta(1, 3)*u(i-2)/dt2

        else if (i .gt. 4) then

           uddot(i) &
                &= beta(2, 1)*u(i)/dt2 &
                &+ beta(2, 2)*u(i-1)/dt2 &
                &+ beta(2, 3)*u(i-2)/dt2 &
                &+ beta(2, 4)*u(i-3)/dt2 &
                &+ beta(2, 5)*u(i-4)/dt2

        end if

     end if

     ! print newton summary
!     write(*,*) "n ", " R ", " dR ", " R/dR ", "  u", "  du"

     ! Newton iteration to get the update
     newton: do n = 1, max_newton_iters

        dR = K + C/dt + M/dt2

        R = -(M*uddot(i) + C*udot(i) + K*u(i))

        ! find the update
        du = R/dR

        ! apply the updates
        u(i) = u(i) + du
        udot(i) = udot(i) + alpha(1, 1)* du/dt
        uddot(i) = uddot(i) + beta(1, 1)*du/dt2

        ! find the norm of the residual
        rnrm = sqrt(R*R)

        ! print newton summary
!        write(*,'(2I2,6E15.4)') n, i, R, dR, R/dR, u(i), du

        if (rnrm .le. rnrm_tol) exit newton

     end do newton

     print *, i, u(i), udot(i), uddot(i)


  end do time_march

end program main
! uddot(i) = uddot(i) + beta(1)*du/(dt*dt) 
===============


! uddot(i) = uddot(i) + beta(1)*du/(dt*dt) 

!!$
!!$        uddot(3) = (u(3)-2.0_dp*u(2)+u(1))/dt2          
!!$
!!$
!!$        if (i .le. 4) then
!!$
!!$
!!$
!!$        else if (i .gt. 4) then
!!$
!!$           uddot(i) &
!!$                &= beta(2, 1)*u(i)/dt2 &
!!$                &+ beta(2, 2)*u(i-1)/dt2 &
!!$                &+ beta(2, 3)*u(i-2)/dt2 &
!!$                &+ beta(2, 4)*u(i-3)/dt2 &
!!$                &+ beta(2, 5)*u(i-4)/dt2
!!$
!!$        end if
!!$
!!$        
        !        if (i .eq. 3) then
        
        !           udot(3)  = (3.0_dp*u(3)-4.0_dp*u(2)+u(1))/(2.0_dp*dt)
        !           uddot(3) = (u(3)-2.0_dp*u(2)+u(1))/dt2          
        ! get the residual
        !           R = M*(u(3)-2.0_dp*u(2)+u(1))/dt2 &
        !                &+ C*(3.0_dp*u(3)-4.0_dp*u(2)+u(1))/(2.0_dp*dt) &
        !                &+ K*u(3)
        !          end if
        
        !
!!$
!!$        else 
!!$           ! get the residual
!!$           R = M*(u(3)-2.0_dp*u(2)+u(1))/dt2 &
!!$                &+ C*(3.0_dp*u(3)-4.0_dp*u(2)+u(1))/(2.0_dp*dt) &
!!$                &+ K*u(3)
!!$        end if
!        udot(i) =  udot(i) + alpha(1, 1)*du/dt
!        uddot(i) =  uddot(i) + beta(1, 1)*du/dt2
